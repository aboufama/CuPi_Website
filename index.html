<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Liquid Glass Effect</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700;900&family=Open+Sans:wght@300;400;700;800&family=Lato:wght@300;400;700;900&family=Montserrat:wght@300;400;700;900&family=Oswald:wght@300;400;700&family=Raleway:wght@300;400;700;900&family=Poppins:wght@300;400;700;900&family=Ubuntu:wght@300;400;700&family=Nunito:wght@300;400;700;900&family=Playfair+Display:wght@400;700;900&family=Inter:wght@300;400;700;900&family=Righteous&family=Bebas+Neue&family=Anton&family=Russo+One&family=Black+Ops+One&family=Bungee&family=Paytone+One&family=Merriweather:wght@300;400;700;900&family=Quicksand:wght@300;400;700&family=Barlow:wght@300;400;700;900&family=Rubik:wght@300;400;700;900&family=Work+Sans:wght@300;400;700;900&family=Josefin+Sans:wght@300;400;700&family=Manrope:wght@300;400;700;800&family=Cabin:wght@400;700&family=Mukta:wght@300;400;700;800&family=Karla:wght@300;400;700;800&family=Exo+2:wght@300;400;700;900&family=Titillium+Web:wght@300;400;700;900&family=Hind:wght@300;400;700&family=Bitter:wght@300;400;700;900&family=Oxygen:wght@300;400;700&family=Asap:wght@300;400;700;900&family=Archivo:wght@300;400;700;900&family=Libre+Franklin:wght@300;400;700;900&family=IBM+Plex+Sans:wght@300;400;700&family=Source+Code+Pro:wght@300;400;700;900&family=PT+Sans:wght@400;700&family=DM+Sans:wght@400;700&family=Noto+Sans:wght@400;700;900&family=Kanit:wght@300;400;700;900&family=Sora:wght@300;400;700;800&family=Space+Grotesk:wght@300;400;700&family=Signika:wght@300;400;700&family=Readex+Pro:wght@300;400;700&family=Plus+Jakarta+Sans:wght@300;400;700;800&family=Epilogue:wght@300;400;700;900&family=Outfit:wght@300;400;700;900&family=Commissioner:wght@300;400;700;900&family=Red+Hat+Display:wght@300;400;700;900&family=Lexend:wght@300;400;700;900&family=Urbanist:wght@300;400;700;900&family=Inconsolata:wght@300;400;700;900&family=Fira+Sans:wght@300;400;700;900&family=Varela+Round&family=Comfortaa:wght@300;400;700&family=Teko:wght@300;400;700&family=Saira:wght@300;400;700;900&family=Archivo+Black&family=Alfa+Slab+One&family=Audiowide&family=Orbitron:wght@400;700;900&family=Righteous&family=Bangers&family=Permanent+Marker&family=Titan+One&family=Fredoka:wght@300;400;700&family=Questrial&family=Fugaz+One&family=Lilita+One&family=Passion+One:wght@400;700;900&family=Staatliches&family=Righteous&family=Yellowtail&family=Caveat:wght@400;700&family=Shadows+Into+Light&family=Indie+Flower&family=Amatic+SC:wght@400;700&family=Satisfy&family=Lobster&family=Pacifico&family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Kaushan+Script&family=Cookie&family=Courgette&family=Righteous&family=Cinzel:wght@400;700;900&family=Cormorant:wght@300;400;700&family=EB+Garamond:wght@400;700&family=Crimson+Text:wght@400;700&family=Lora:wght@400;700&family=Spectral:wght@300;400;700&family=Cardo:wght@400;700&family=Libre+Baskerville:wght@400;700&family=Old+Standard+TT:wght@400;700&family=Crete+Round:wght@400&family=Alegreya:wght@400;700;900&family=Volkhov:wght@400;700&family=Neuton:wght@300;400;700;800&display=swap" rel="stylesheet">
  <style>
    /* LIQUID GLASS STYLES */

    .liquidGlass-wrapper {
      position: relative;
      display: flex;
      font-weight: 600;
      overflow: hidden;

      box-shadow: 0 4px 4px rgba(0, 0, 0, 0.05), 0 0 15px rgba(0, 0, 0, 0.03);
    }

    .custom-cursor {
      position: absolute;
      width: 16px;
      height: 16px;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      transition: opacity 0.15s;
      transform: translate(-2px, -2px);
    }

    .custom-cursor::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
      border-left: 8px solid rgba(0, 0, 0, 0.8);
      border-right: 8px solid transparent;
      border-top: 8px solid rgba(0, 0, 0, 0.8);
      border-bottom: 8px solid transparent;
      transform: scaleX(0.45);
      transform-origin: top left;
      filter: drop-shadow(0 1px 2px rgba(255, 255, 255, 0.5));
    }

    .liquidGlass-effect {
      position: absolute;
      z-index: 1;
      inset: 0;

      backdrop-filter: blur(2.5px);
      filter: url(#glass-distortion);
      overflow: hidden;
      will-change: filter, backdrop-filter;
      pointer-events: none;
      transform: translateZ(0);
    }

    .liquidGlass-tint {
      z-index: 2;
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.04);
      pointer-events: none;
    }

    .liquidGlass-shine {
      position: absolute;
      inset: 0;
      z-index: 3;

      overflow: hidden;
      pointer-events: none;

      box-shadow: inset 2px 2px 1px 0 rgba(255, 255, 255, 0.6),
        inset -1px -1px 1px 1px rgba(255, 255, 255, 0.6);
    }

    .liquidGlass-text {
      position: relative;
      z-index: 4;
      color: #000000;
      opacity: 0.9;
    }

    /* OTHER STYLES */

    html {
      overflow-x: hidden;
      overscroll-behavior-y: none;
    }

    body {
      padding: 0;
      margin: 0;
      min-height: 100vh;
      background: white;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-weight: 400;
      overflow-x: hidden;
      overscroll-behavior-y: none;
      scrollbar-width: none;
    }

    body::-webkit-scrollbar,
    html::-webkit-scrollbar {
      display: none;
      width: 0;
      height: 0;
    }

    body.hide-cursor {
      cursor: none;
    }

    body.hide-cursor * {
      cursor: none !important;
    }

    /*
    GREEN BACKGROUND
    https://media.istockphoto.com/id/1430511443/vector/christmas-mistletoe-foliage-and-berries-vector-seamless-pattern.jpg?s=612x612&w=0&k=20&c=oqxlH7ytgd5yjBQroACirJ1gH7Au1tq8gmsdeGd-Crk=

    ORANGE BACKGROUND
    https://images.fineartamerica.com/images/artworkimages/mediumlarge/3/beautiful-orange-and-pastel-flowers-seamless-pattern-julien.jpg

    MARGARITAS BACKGROUND
    https://static.vecteezy.com/system/resources/previews/056/652/082/non_2x/hand-drawn-white-flower-seamless-pattern-floral-repeating-wallpaper-for-textile-design-fabric-print-wrapping-paper-cute-daisy-flowers-on-blue-background-repeated-ditsy-texture-vector.jpg

    SPRING FLOWERS BACKGROUND
    https://img.freepik.com/free-vector/flat-floral-spring-pattern-design_23-2150117078.jpg

    VECTOR WINDS BACKGROUND
    https://i.ibb.co/MDbLn4N4/vectors.png

    RED FLOWERS BACKGROUND
    https://www.publicdomainpictures.net/pictures/610000/velka/seamless-floral-wallpaper-art-1715193626Gct.jpg
    */

    a {
      text-decoration: none;
    }

    .hero-section {
      width: 100%;
      min-height: 100vh;
      background: url('Title.png') center top no-repeat;
      background-size: 100% auto;
      background-attachment: scroll;
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      position: relative;
      overflow-x: hidden;
      will-change: transform;
    }

    .wrapper {
      display: flex;
      gap: 50px;
      flex-direction: column;
      justify-content: flex-end;
      align-items: flex-start;
    }

    .content-section {
      width: 100%;
      padding: 0.25rem 2rem 0;
      background: white;
      margin-bottom: 0;
    }

    .about-section {
      max-width: 1200px;
      margin: 0 auto;
    }

    .section-title {
      font-size: 3rem;
      font-family: 'Righteous', sans-serif;
      text-align: center;
      margin-bottom: 1rem;
      color: #000000;
      overflow: hidden;
      white-space: nowrap;
    }

    .section-title.typing::after {
      content: '|';
      animation: blink 0.7s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .intro-text {
      font-size: 0.95rem;
      text-align: center;
      color: #555;
      max-width: 1000px;
      margin: 0 auto 1.5rem;
      line-height: 1.4;
      font-weight: 500;
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 1.5rem;
    }

    .info-card {
      position: relative;
      background: transparent;
      padding: 1.5rem 2rem;
      border-radius: 2rem;
      box-shadow: 0 4px 4px rgba(0, 0, 0, 0.05), 0 0 15px rgba(0, 0, 0, 0.03);
      overflow: hidden;
      isolation: isolate;
    }

    .info-card::before {
      content: '';
      position: absolute;
      inset: 0;
      backdrop-filter: blur(2.5px);
      filter: url(#glass-distortion);
      overflow: hidden;
      pointer-events: none;
      transform: translateZ(0);
      z-index: 1;
    }

    .info-card::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.04);
      pointer-events: none;
      z-index: 2;
      box-shadow: inset 2px 2px 1px 0 rgba(255, 255, 255, 0.6),
        inset -1px -1px 1px 1px rgba(255, 255, 255, 0.6);
    }

    .info-card h3 {
      font-size: 1.25rem;
      font-family: 'Righteous', sans-serif;
      color: #000000;
      margin-bottom: 0.5rem;
      margin-top: 0;
      position: relative;
      z-index: 3;
    }

    .info-card p {
      font-size: 0.9rem;
      line-height: 1.5;
      color: #555;
      margin: 0;
      text-align: left;
      position: relative;
      z-index: 3;
    }

    .info-card-cursor {
      position: absolute;
      width: 16px;
      height: 16px;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      transition: opacity 0.15s;
      transform: translate(-2px, -2px);
    }

    .info-card-cursor::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
      border-left: 8px solid rgba(0, 0, 0, 0.8);
      border-right: 8px solid transparent;
      border-top: 8px solid rgba(0, 0, 0, 0.8);
      border-bottom: 8px solid transparent;
      transform: scaleX(0.45);
      transform-origin: top left;
      filter: drop-shadow(0 1px 2px rgba(255, 255, 255, 0.5));
    }

    .timeline-section {
      padding: 9rem 0 2rem 0;
      background: white;
    }

    .timeline {
      position: relative;
      width: 100%;
      margin: 0 auto;
      padding: 2rem 0;
      overflow: visible;
    }

    .timeline-line {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background: #000;
      transform: translateY(-50%);
    }

    .timeline-items {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      z-index: 2;
    }

    .timeline-event {
      position: relative;
      text-align: center;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 120px;
      z-index: 3;
    }

    .timeline-event::before {
      content: '';
      width: 12px;
      height: 12px;
      background: #000;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
    }

    .timeline-event:nth-child(odd) {
      justify-content: flex-end;
      padding-bottom: 2rem;
    }

    .timeline-event:nth-child(even) {
      justify-content: flex-start;
      padding-top: 2rem;
    }

    .timeline-date {
      font-size: 0.85rem;
      font-weight: 500;
      color: #666;
      position: absolute;
      top: calc(50% + 1rem);
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      z-index: 3;
    }

    .timeline-title {
      font-size: 1rem;
      font-weight: 600;
      color: #000;
      max-width: 140px;
      border: 1px solid #000;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      position: relative;
      z-index: 3;
    }

    .timeline-event:nth-child(odd) .timeline-title {
      position: absolute;
      bottom: calc(50% + 2.5rem);
    }

    .timeline-event:nth-child(even) .timeline-title {
      position: absolute;
      top: calc(50% + 2.5rem);
    }

    .timeline-divider {
      position: absolute;
      top: 1.2rem;
      bottom: 1.2rem;
      left: 37%;
      width: 2px;
      background: #8B0000;
    }

    .timeline-tag {
      position: absolute;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #000;
    }

    .timeline-tag.past {
      left: calc(37% - 0.5rem);
      bottom: 2rem;
      transform: translateX(-100%);
    }

    .timeline-tag.future {
      left: calc(37% + 0.5rem);
      top: 1.2rem;
    }

    .timeline-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 12;
      opacity: 0;
      transform: translate3d(0, calc(50% - 9px), 0);
      transition:
        transform 0.28s ease,
        width 0.28s ease,
        height 0.28s ease,
        border-radius 0.32s ease,
        opacity 0.2s ease,
        background 0.45s ease,
        border 0.45s ease,
        box-shadow 0.45s ease;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      overflow: hidden;
      isolation: isolate;
      border: 1px solid rgba(255, 255, 255, 0.65);
      box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.2),
        0 4px 8px rgba(0, 0, 0, 0.18);
      background: rgba(255, 255, 255, 0.05);
      --overlay-base-blur: 1px;
      --overlay-locked-blur: 5px;
    }

    .timeline-overlay .overlay-glass {
      position: absolute;
      inset: 0;
      backdrop-filter: blur(var(--overlay-base-blur));
      filter: url(#glass-distortion);
      pointer-events: none;
      z-index: 1;
      transition: backdrop-filter 0.45s ease;
    }

    .timeline-overlay .overlay-tint {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.08);
      pointer-events: none;
      z-index: 2;
      transition: background 0.45s ease;
    }

    .timeline-overlay .overlay-shine {
      position: absolute;
      inset: 0;
      box-shadow:
        inset 2px 2px 1px rgba(255, 255, 255, 0.65),
        inset -1px -1px 1px rgba(255, 255, 255, 0.4),
        inset 0 0 0 0.5px rgba(255, 255, 255, 0.55);
      pointer-events: none;
      z-index: 3;
      transition: box-shadow 0.45s ease;
    }

    .timeline-overlay.prelock {
      border-width: 1.4px;
      background: rgba(255, 255, 255, 0.2);
      box-shadow:
        0 12px 22px rgba(0, 0, 0, 0.24),
        0 5px 12px rgba(0, 0, 0, 0.18);
    }

    .timeline-overlay.prelock .overlay-tint {
      background: rgba(255, 255, 255, 0.32);
    }

    .timeline-overlay.prelock .overlay-shine {
      box-shadow:
        inset 3px 3px 2px rgba(255, 255, 255, 0.66),
        inset -2px -2px 2px rgba(255, 255, 255, 0.5),
        inset 0 0 0 0.9px rgba(255, 255, 255, 0.58);
    }

    .timeline-overlay.locked {
      border-width: 1.6px;
      background: rgba(255, 255, 255, 0.58);
      box-shadow:
        0 18px 30px rgba(0, 0, 0, 0.32),
        0 8px 16px rgba(0, 0, 0, 0.26);
    }

    .timeline-overlay.locked .overlay-glass {
      backdrop-filter: blur(var(--overlay-locked-blur));
    }

    .timeline-overlay.locked .overlay-tint {
      background: rgba(255, 255, 255, 0.72);
    }

    .timeline-overlay.locked .overlay-shine {
      box-shadow:
        inset 6px 6px 3px rgba(255, 255, 255, 0.78),
        inset -3px -3px 3px rgba(255, 255, 255, 0.62),
        inset 0 0 0 1.2px rgba(255, 255, 255, 0.7);
    }

    .timeline-overlay .overlay-content {
      position: relative;
      z-index: 4;
      display: block;
      padding: 0.55rem 0.9rem 0.8rem 0.9rem;
      text-align: left;
      font-size: 0.85rem;
      font-weight: 600;
      line-height: 1.35;
      color: rgba(20, 20, 20, 0.86);
      opacity: 0;
      transition: opacity 0.2s ease;
      letter-spacing: 0.01em;
      white-space: pre-wrap;
      max-width: 180px;
      word-break: break-word;
    }

    .timeline-overlay.locked .overlay-content {
      opacity: 1;
    }

    .overlay-text {
      display: block;
      width: 100%;
    }

    @media (max-width: 768px) {
      .timeline-section {
        padding: 9rem 0 2rem 0;
      }

      .timeline {
        padding: 2rem 1rem;
      }

      .timeline-items {
        flex-direction: column;
        gap: 3rem;
      }

      .timeline-line {
        top: 0;
        bottom: 0;
        left: 50%;
        right: auto;
        width: 2px;
        height: 100%;
        transform: translateX(-50%);
      }

      .timeline-event {
        flex-direction: row !important;
        text-align: left;
      }

      .timeline-event::before {
        margin: 0 1rem 0 0 !important;
      }

      .timeline-divider,
      .timeline-tag {
        display: none;
      }

      .timeline-title {
        max-width: 100%;
      }

      .timeline-overlay {
        display: none;
      }
    }

    .font-selector {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #000;
      padding: 1rem 1.5rem;
      border-radius: 0.75rem;
      border: 2px solid #fff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 280px;
    }

    .font-selector.visible {
      display: flex;
    }

    .font-selector label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .font-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .font-arrow {
      background: #fff;
      color: #000;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 0.5rem;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .font-arrow:hover {
      background: #ddd;
    }

    .font-arrow:active {
      background: #bbb;
    }

    .font-selector input[type="range"] {
      flex: 1;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background: #444;
      height: 6px;
      border-radius: 3px;
      outline: none;
    }

    .font-selector input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }

    .font-selector input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .font-name {
      font-size: 0.85rem;
      color: #fff;
      text-align: center;
      font-weight: 500;
    }

    .font-selector input[type="color"] {
      width: 100%;
      height: 40px;
      border: 2px solid #fff;
      border-radius: 0.5rem;
      cursor: pointer;
      background: transparent;
    }

    .site-footer {
      font-size: 0.65rem;
      color: #555;
      text-align: center;
      padding: 3rem 1rem 2.5rem;
      line-height: 1.4;
    }

    .site-footer a {
      color: inherit;
      text-decoration: underline;
    }


    .liquidGlass-wrapper {
      padding: 1rem 2rem;
      border-radius: 2rem;
      position: absolute;
      top: 15%;
      left: 5%;
      isolation: isolate;
      will-change: transform;
    }

    .liquidGlass-wrapper,
    .liquidGlass-wrapper > div {
      border-radius: 2rem;
    }

    .content {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4.5rem;
      font-family: 'Righteous', sans-serif;
      font-weight: 400;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    @keyframes moveBackground {
      from {
        background-position: 0% 0%;
      }
      to {
        background-position: 0% -1500%;
      }
    }

    @media (max-width: 768px) {
      .section-title {
        font-size: 2rem;
      }

      .intro-text {
        font-size: 1rem;
      }

      .info-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .info-card {
        padding: 1.25rem;
      }

      .info-card h3 {
        font-size: 1.1rem;
      }

      .info-card p {
        font-size: 0.85rem;
      }

      .liquidGlass-wrapper {
        padding: 0.75rem 1.5rem;
      }

      .content {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="hero-section">
    <div class="wrapper">
      <div class="liquidGlass-wrapper">
        <div class="custom-cursor"></div>
        <div class="liquidGlass-effect"></div>
        <div class="liquidGlass-tint"></div>
        <div class="liquidGlass-shine"></div>
        <div class="liquidGlass-text">
          <div class="content">
            Cornell Physical Intelligence
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="content-section">
    <div class="about-section">
      <h2 class="section-title">Mission</h2>
      <p class="intro-text">
        Cornell Physical Intelligence (CuPI) conducts interdisciplinary research in physical AI with a focus on intelligent robotics.
      </p>
      <div class="info-grid">
        <div class="info-card">
          <div class="info-card-cursor"></div>
          <h3>Research Philosophy</h3>
          <p>
            We emphasize embodied and morphological intelligence—structural design contributing to perception, learning, and 
            decision-making. Through hands-on research and prototyping, we develop adaptive systems across aerial and terrestrial platforms.
          </p>
        </div>
        
        <div class="info-card">
          <div class="info-card-cursor"></div>
          <h3>What We Build</h3>
          <p>
            We develop autonomous robots that interact with the world independently. Our projects include robot arms, flying vehicles, 
            and driven platforms—all integrating mechanical, electrical, and AI components for autonomous decision-making.
          </p>
        </div>
        
        <div class="info-card">
          <div class="info-card-cursor"></div>
          <h3>Team Structure</h3>
          <p>
            Our team unites students from mechanical, electrical, and computer science fields. Members work on hardware design, 
            control systems, AI algorithms, and behavior planning—proving innovation emerges from interdisciplinary collaboration.
          </p>
        </div>
      </div>
    </div>

  </div>

<section class="timeline-section" id="timelineSection">
  <div class="timeline">
      <div class="timeline-line"></div>
      <div class="timeline-overlay">
        <div class="overlay-glass"></div>
        <div class="overlay-tint"></div>
        <div class="overlay-shine"></div>
        <div class="overlay-content">
          <span class="overlay-text"></span>
        </div>
      </div>
      <div class="timeline-divider"></div>
      <span class="timeline-tag past">Past</span>
    <span class="timeline-tag future">Future</span>
    <ul class="timeline-items">
      <li class="timeline-event" data-description="Cornell Physical Intelligence (CuPI)&#10;Recognized under Campus Activities Policy 4.10.&#10;CuPI acronym authorized for outreach.&#10;Mission: conduct rigorous interdisciplinary research in physical AI." style="margin-right: 3rem;">
        <span class="timeline-date">Aug 2025</span>
        <h3 class="timeline-title">Club Founded</h3>
      </li>
      <li class="timeline-event" data-description="Cicada ISR Drone v1&#10;First-generation reconnaissance airframe for physical AI studies.&#10;Off-the-shelf electronics validate avionics and sensing stack.&#10;Embodied intelligence insights guide future CuPI-built hardware." style="margin-right: 7rem;">
        <span class="timeline-date">Sep 2025</span>
        <h3 class="timeline-title">"Cicada" Prototype</h3>
      </li>
      <li class="timeline-event" data-description="Cicada Refinement Cycle&#10;Shifts toward custom avionics and autonomy loops.&#10;Iterates aerodynamics, compliance, and ISR payload integration.&#10;Data informs embodied strategies for mission agility." >
        <span class="timeline-date">Nov 2025</span>
        <h3 class="timeline-title">Cicada Refinement</h3>
      </li>
      <li class="timeline-event" data-description="Ground AI Crawler&#10;Embodied intelligence applied to legged robotics.&#10;Explores compliant structures and capstan-drive actuation.&#10;Targets robust perception and decision-making on varied terrain." >
        <span class="timeline-date">Nov 2025</span>
        <h3 class="timeline-title">Ground AI Crawler</h3>
      </li>
      <li class="timeline-event" data-description="Aerobatic Control Model&#10;Model-based control and simulation for agile CuPI aircraft.&#10;Couples mechanical, electrical, and AI feedback loops.&#10;Builds reusable libraries for high-agility autonomy behaviors." >
        <span class="timeline-date">Dec 2025</span>
        <h3 class="timeline-title">Aerobatic Control Model</h3>
      </li>
      <li class="timeline-event" data-description="Biomechanical AI Foundation Model&#10;Long-term roadmap: robot arm, autonomous flyer, and driven vehicle.&#10;Explores cross-domain physical intelligence and capstan drives.&#10;Aligns hardware and software roadmaps for adaptive resilience." >
        <span class="timeline-date">Jan 2026</span>
        <h3 class="timeline-title">Biomechanical AI Foundation Model</h3>
      </li>
    </ul>
  </div>
</section>

<div class="font-selector" id="fontSelector">
    <label>
      <span>Font Selector</span>
      <span id="fontNumber">68</span>
    </label>
    <div class="font-controls">
      <button class="font-arrow" id="fontPrev">←</button>
      <input type="range" id="fontSlider" min="1" max="100" value="68" step="1">
      <button class="font-arrow" id="fontNext">→</button>
    </div>
    <div class="font-name" id="fontName">Permanent Marker</div>
    
    <label style="margin-top: 1rem;">
      <span>Title Color</span>
      <span id="colorValue">#000000</span>
    </label>
    <input type="color" id="colorPicker" value="#000000">
  </div>

  <svg style="display: none">
    <filter
      id="glass-distortion"
      x="0%"
      y="0%"
      width="100%"
      height="100%"
      filterUnits="objectBoundingBox"
    >
      <feTurbulence
        type="fractalNoise"
        baseFrequency="0.01 0.01"
        numOctaves="1"
        seed="5"
        result="turbulence"
      />
      <!-- Seeds: 14, 17,  -->

      <feComponentTransfer in="turbulence" result="mapped">
        <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
        <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
        <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
      </feComponentTransfer>

      <feGaussianBlur in="turbulence" stdDeviation="4" result="softMap" />

      <feSpecularLighting
        in="softMap"
        surfaceScale="5"
        specularConstant="1"
        specularExponent="100"
        lighting-color="white"
        result="specLight"
      >
        <fePointLight x="-200" y="-200" z="300" />
      </feSpecularLighting>

      <feComposite
        in="specLight"
        operator="arithmetic"
        k1="0"
        k2="1"
        k3="1"
        k4="0"
        result="litImage"
      />

      <feDisplacementMap
        in="SourceGraphic"
        in2="softMap"
        scale="15"
        xChannelSelector="R"
        yChannelSelector="G"
      />
    </filter>
  </svg>

  <footer class="site-footer">
    <div>This organization is a registered student organization of Cornell University.</div>
    <div>Equal Education and Employment: <a href="https://hr.cornell.edu/about/workplace-rights/equal-education-and-employment">https://hr.cornell.edu/about/workplace-rights/equal-education-and-employment</a></div>
    <div>For Questions &amp; Sponsorship Inquiries:</div>
    <div>Contact <a href="mailto:cuphysicalintelligence@cornell.org">cuphysicalintelligence@cornell.org</a></div>
  </footer>

  <script>
    const glassWrapper = document.querySelector('.liquidGlass-wrapper');
    const customCursor = document.querySelector('.custom-cursor');
    const body = document.body;
    const heroSection = document.querySelector('.hero-section');
    const fontSlider = document.getElementById('fontSlider');
    const fontNumber = document.getElementById('fontNumber');
    const fontName = document.getElementById('fontName');
    const fontPrev = document.getElementById('fontPrev');
    const fontNext = document.getElementById('fontNext');
    const fontSelector = document.getElementById('fontSelector');
    const colorPicker = document.getElementById('colorPicker');
    const colorValue = document.getElementById('colorValue');
    const liquidGlassText = document.querySelector('.liquidGlass-text');
    const timeline = document.querySelector('.timeline');
    const timelineOverlay = document.querySelector('.timeline-overlay');
    const timelineEvents = document.querySelectorAll('.timeline-event');
    const overlayText = document.querySelector('.overlay-text');
    
    let parallaxRatio = 0.45;

    // 100 Google Fonts
    const fonts = [
      'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Oswald', 'Raleway', 'Poppins', 'Ubuntu', 'Nunito', 'Playfair Display',
      'Inter', 'Righteous', 'Bebas Neue', 'Anton', 'Russo One', 'Black Ops One', 'Bungee', 'Paytone One', 'Merriweather', 'Quicksand',
      'Barlow', 'Rubik', 'Work Sans', 'Josefin Sans', 'Manrope', 'Cabin', 'Mukta', 'Karla', 'Exo 2', 'Titillium Web',
      'Hind', 'Bitter', 'Oxygen', 'Asap', 'Archivo', 'Libre Franklin', 'IBM Plex Sans', 'Source Code Pro', 'PT Sans', 'DM Sans',
      'Noto Sans', 'Kanit', 'Sora', 'Space Grotesk', 'Signika', 'Readex Pro', 'Plus Jakarta Sans', 'Epilogue', 'Outfit', 'Commissioner',
      'Red Hat Display', 'Lexend', 'Urbanist', 'Inconsolata', 'Fira Sans', 'Varela Round', 'Comfortaa', 'Teko', 'Saira', 'Archivo Black',
      'Alfa Slab One', 'Audiowide', 'Orbitron', 'Bangers', 'Permanent Marker', 'Titan One', 'Fredoka', 'Questrial', 'Fugaz One', 'Lilita One',
      'Passion One', 'Staatliches', 'Yellowtail', 'Caveat', 'Shadows Into Light', 'Indie Flower', 'Amatic SC', 'Satisfy', 'Lobster', 'Pacifico',
      'Dancing Script', 'Great Vibes', 'Kaushan Script', 'Cookie', 'Courgette', 'Cinzel', 'Cormorant', 'EB Garamond', 'Crimson Text', 'Lora',
      'Spectral', 'Cardo', 'Libre Baskerville', 'Old Standard TT', 'Crete Round', 'Alegreya', 'Volkhov', 'Neuton', 'Georgia', 'Arial'
    ];

    const overlayConfig = Object.freeze({
      baseSize: 60,
      minWidth: 170,
      textExtraWidth: 24,
      titleExtraWidth: 24,
      maxWidth: 180,
      contentPadding: 18,
      baseBlur: 1.0,
      lockedBlur: 5.0,
      travelDelay: 180,
      expandDelay: 200,
      frostDelay: 350,
    });

    const overlayDefaults = {
      get width() {
        return overlayConfig.baseSize;
      },
      get height() {
        return overlayConfig.baseSize;
      },
      get radius() {
        return '50%';
      },
    };

    const overlayCharWidth = 7.5;
    let overlayAnimationFrame = null;
    let pendingOverlayState = null;
    let currentOverlayState = null;
    let currentLockedEvent = null;
    let pendingLockedEvent = null;
    let expandTimeoutId = null;
    let travelTimeoutId = null;
    let frostTimeoutId = null;

    if (timelineOverlay) {
      timelineOverlay.style.setProperty('--overlay-base-blur', `${overlayConfig.baseBlur}px`);
      timelineOverlay.style.setProperty('--overlay-locked-blur', `${overlayConfig.lockedBlur}px`);
    }

    function scheduleOverlayUpdate(state) {
      pendingOverlayState = state;

      if (overlayAnimationFrame) {
        return;
      }

      overlayAnimationFrame = requestAnimationFrame(() => {
        overlayAnimationFrame = null;
        if (!timelineOverlay || !pendingOverlayState) {
          return;
        }

        const { x, y, width, height, radius, opacity } = pendingOverlayState;
        timelineOverlay.style.width = `${width}px`;
        timelineOverlay.style.height = `${height}px`;
        timelineOverlay.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        timelineOverlay.style.borderRadius = radius;
        timelineOverlay.style.opacity = opacity;
        pendingOverlayState = null;
        currentOverlayState = { x, y, width, height, radius, opacity };
      });
    }

    function setOverlayState(state, text = '') {
      if (!timelineOverlay) {
        return;
      }

      if (state === 'clear') {
        timelineOverlay.classList.remove('prelock', 'locked');
        if (overlayText) {
          overlayText.textContent = '';
        }
      } else if (state === 'prelock') {
        timelineOverlay.classList.remove('locked');
        timelineOverlay.classList.add('prelock');
        if (overlayText) {
          overlayText.textContent = text;
        }
      } else if (state === 'locked') {
        timelineOverlay.classList.remove('prelock');
        timelineOverlay.classList.add('locked');
        if (overlayText) {
          overlayText.textContent = text;
        }
      }
    }

    function beginOverlayLock(text) {
      clearTimeout(frostTimeoutId);
      setOverlayState('prelock', text);
      frostTimeoutId = setTimeout(() => {
        setOverlayState('locked', text);
        frostTimeoutId = null;
      }, overlayConfig.frostDelay);
    }

    function resetOverlayState() {
      clearTimeout(frostTimeoutId);
      frostTimeoutId = null;
      setOverlayState('clear');
    }

    function expandToEvent(eventElement) {
      if (!timeline || !timelineOverlay || !eventElement) {
        return;
      }

      const rect = timeline.getBoundingClientRect();
      const centerY = rect.height / 2;
      const eventRect = eventElement.getBoundingClientRect();
      const eventCenterX = eventRect.left - rect.left + eventRect.width / 2;
      const titleEl = eventElement.querySelector('.timeline-title');
      const titleRect = titleEl ? titleEl.getBoundingClientRect() : null;
      const overlayCopy =
        eventElement.dataset.description ||
        eventElement.dataset.placeholder ||
        (titleEl ? titleEl.textContent.trim() : 'Timeline event');

      if (overlayText && overlayText.textContent !== overlayCopy) {
        overlayText.textContent = overlayCopy;
      }

      const textWidthEstimate = overlayCopy.length * overlayCharWidth;

      const lockedWidth = Math.max(
        overlayConfig.minWidth,
        Math.min(
          overlayConfig.maxWidth,
          Math.max(
            textWidthEstimate + overlayConfig.textExtraWidth,
            (titleRect ? titleRect.width : 0) + overlayConfig.titleExtraWidth
          )
        )
      );

      if (timelineOverlay) {
        timelineOverlay.style.width = `${lockedWidth}px`;
      }

      const contentHeight = overlayText ? overlayText.scrollHeight + overlayConfig.contentPadding : 0;

      const lockedHeight = Math.max(
        overlayConfig.baseSize,
        contentHeight
      );

      const translateX = eventCenterX - lockedWidth / 2;
      const translateY = centerY - lockedHeight / 2;

      const isCurrent = currentLockedEvent === eventElement;
      const isLocked = timelineOverlay.classList.contains('locked');
      const isPrelock = timelineOverlay.classList.contains('prelock');

      if (!isCurrent || (!isLocked && !isPrelock)) {
        beginOverlayLock(overlayCopy);
      }

      scheduleOverlayUpdate({
        x: translateX,
        y: translateY,
        width: lockedWidth,
        height: lockedHeight,
        radius: '28px',
        opacity: 1,
      });

      currentLockedEvent = eventElement;
      pendingLockedEvent = null;
      expandTimeoutId = null;
    }

    function shrinkThenExpand(eventElement) {
      if (!timeline || !timelineOverlay || !eventElement) {
        return;
      }

      clearTimeout(expandTimeoutId);
      clearTimeout(travelTimeoutId);

      const rect = timeline.getBoundingClientRect();
      const baseSize = overlayConfig.baseSize;
      const eventRect = eventElement.getBoundingClientRect();
      const eventCenterX = eventRect.left - rect.left + eventRect.width / 2;
      const defaultCenterY = rect.height / 2;
      const collapseCenterX = currentOverlayState
        ? currentOverlayState.x + currentOverlayState.width / 2
        : eventCenterX;
      const collapseCenterY = currentOverlayState
        ? currentOverlayState.y + currentOverlayState.height / 2
        : defaultCenterY;

      resetOverlayState();
      currentLockedEvent = null;
      pendingLockedEvent = eventElement;

      scheduleOverlayUpdate({
        x: collapseCenterX - baseSize / 2,
        y: collapseCenterY - baseSize / 2,
        width: baseSize,
        height: baseSize,
        radius: overlayDefaults.radius,
        opacity: 1,
      });

      travelTimeoutId = setTimeout(() => {
        scheduleOverlayUpdate({
          x: eventCenterX - baseSize / 2,
          y: defaultCenterY - baseSize / 2,
          width: baseSize,
          height: baseSize,
          radius: overlayDefaults.radius,
          opacity: 1,
        });
        travelTimeoutId = null;
      }, overlayConfig.travelDelay);

      expandTimeoutId = setTimeout(() => {
        expandToEvent(eventElement);
      }, overlayConfig.travelDelay + overlayConfig.expandDelay);
    }

    function handleTimelinePointer(e) {
      if (!timeline || !timelineOverlay) {
        return;
      }

      const rect = timeline.getBoundingClientRect();
      const pointerXRaw = e.clientX - rect.left;
      const pointerY = e.clientY;
      const activationBand = rect.height / 2 + 140;
      const timelineCenterScreenY = rect.top + rect.height / 2;

      if (
        pointerY < timelineCenterScreenY - activationBand ||
        pointerY > timelineCenterScreenY + activationBand
      ) {
        hideTimelineOverlay();
        return;
      }

      const clampedX = Math.max(0, Math.min(rect.width, pointerXRaw));
      const centerY = rect.height / 2;

      let closestEvent = null;

      timelineEvents.forEach((event) => {
        const eventRect = event.getBoundingClientRect();
        const eventCenterX = eventRect.left - rect.left + eventRect.width / 2;
        const distance = Math.abs(clampedX - eventCenterX);

        if (!closestEvent || distance < closestEvent.distance) {
          closestEvent = {
            event,
            distance,
            centerX: eventCenterX,
            eventRect,
          };
        }
      });

      if (!closestEvent) {
        hideTimelineOverlay();
        return;
      }

      const magnetRadius = Math.max(
        overlayConfig.baseSize * 5,
        closestEvent.eventRect.width / 2 + overlayConfig.textExtraWidth
      );

      if (closestEvent.distance > magnetRadius) {
        resetOverlayState();
        currentLockedEvent = null;
        pendingLockedEvent = null;
        clearTimeout(expandTimeoutId);
        const translateX = clampedX - overlayDefaults.width / 2;
        const translateY = centerY - overlayDefaults.height / 2;

        scheduleOverlayUpdate({
          x: translateX,
          y: translateY,
          width: overlayDefaults.width,
          height: overlayDefaults.height,
          radius: overlayDefaults.radius,
          opacity: 1,
        });
        return;
      }

      if (currentLockedEvent === closestEvent.event) {
        expandToEvent(closestEvent.event);
        return;
      }

      if (pendingLockedEvent === closestEvent.event) {
        return;
      }

      shrinkThenExpand(closestEvent.event);
    }

    function hideTimelineOverlay() {
      if (!timelineOverlay) {
        return;
      }

      resetOverlayState();
      currentLockedEvent = null;
      pendingLockedEvent = null;
      clearTimeout(expandTimeoutId);
      clearTimeout(travelTimeoutId);
      expandTimeoutId = null;
      travelTimeoutId = null;

      const timelineRect = timeline ? timeline.getBoundingClientRect() : null;
      const fallbackX = timelineRect ? timelineRect.width / 2 - overlayDefaults.width / 2 : 0;
      const fallbackY = timelineRect ? timelineRect.height / 2 - overlayDefaults.height / 2 : 0;

      const lastState = currentOverlayState || {
        x: fallbackX,
        y: fallbackY,
        width: overlayDefaults.width,
        height: overlayDefaults.height,
      };

      const shrinkWidth = overlayDefaults.width;
      const shrinkHeight = overlayDefaults.height;

      const shrinkX = lastState.x + (lastState.width - shrinkWidth) / 2;
      const shrinkY = lastState.y + (lastState.height - shrinkHeight) / 2;

      scheduleOverlayUpdate({
        x: shrinkX,
        y: shrinkY,
        width: shrinkWidth,
        height: shrinkHeight,
        radius: overlayDefaults.radius,
        opacity: 0,
      });
    }

    // Unified cursor effect for all glass elements
    const infoCards = document.querySelectorAll('.info-card');
    let isOverGlass = false;

    document.addEventListener('mousemove', (e) => {
      if (!glassWrapper || !customCursor) {
        return;
      }

      isOverGlass = false;

      // Check title glass wrapper
      const titleRect = glassWrapper.getBoundingClientRect();
      const titleX = e.clientX - titleRect.left;
      const titleY = e.clientY - titleRect.top;
      
      if (titleX >= -16 && titleX <= titleRect.width + 12 && titleY >= -16 && titleY <= titleRect.height + 12) {
        customCursor.style.left = titleX + 'px';
        customCursor.style.top = titleY + 'px';
        customCursor.style.opacity = '1';
        isOverGlass = true;
      } else {
        customCursor.style.opacity = '0';
      }

      // Check all info cards
      infoCards.forEach(card => {
        const cardCursor = card.querySelector('.info-card-cursor');
        if (!cardCursor) {
          return;
        }

        const cardRect = card.getBoundingClientRect();
        const cardX = e.clientX - cardRect.left;
        const cardY = e.clientY - cardRect.top;
        
        if (cardX >= -16 && cardX <= cardRect.width + 12 && cardY >= -16 && cardY <= cardRect.height + 12) {
          cardCursor.style.left = cardX + 'px';
          cardCursor.style.top = cardY + 'px';
          cardCursor.style.opacity = '1';
          isOverGlass = true;
        } else {
          cardCursor.style.opacity = '0';
        }
      });

      // Hide/show native cursor based on any glass element
      if (isOverGlass) {
        body.classList.add('hide-cursor');
      } else {
        body.classList.remove('hide-cursor');
      }
    });

    // Simple timeline - no animations needed

    // Parallax scroll effect for title and background
    window.addEventListener('scroll', () => {
      const scrollY = window.scrollY;
      
      if (scrollY < 0) {
        window.scrollTo(0, 0);
        return;
      }
      
      if (heroSection) {
        heroSection.style.transform = `translateY(${scrollY * 0}px)`;
      }

      if (glassWrapper) {
        glassWrapper.style.transform = `translateY(${scrollY * parallaxRatio}px)`;
      }
    });

    // Font slider and arrow buttons
    function updateFont(value) {
      const fontIndex = parseInt(value) - 1;
      const selectedFont = fonts[fontIndex];
      if (!selectedFont) {
        return;
      }

      if (fontNumber) {
        fontNumber.textContent = value;
      }

      if (fontName) {
        fontName.textContent = selectedFont;
      }

      if (fontSlider) {
        fontSlider.value = value;
      }
      
      // Apply font to entire body
      body.style.fontFamily = `'${selectedFont}', sans-serif`;
      
      // Apply to title
      const titleContent = document.querySelector('.content');
      if (titleContent) {
        titleContent.style.fontFamily = `'${selectedFont}', sans-serif`;
      }
      
      // Apply to section title
      const sectionTitle = document.querySelector('.section-title');
      if (sectionTitle) {
        sectionTitle.style.fontFamily = `'${selectedFont}', sans-serif`;
      }
      
      // Apply to all subtitles (h3 elements)
      const subtitles = document.querySelectorAll('.info-card h3');
      subtitles.forEach(subtitle => {
        subtitle.style.fontFamily = `'${selectedFont}', sans-serif`;
      });

      const timelineTextNodes = document.querySelectorAll('.timeline-date, .timeline-title');
      timelineTextNodes.forEach(node => {
        node.style.fontFamily = `'${selectedFont}', sans-serif`;
      });
    }

    if (fontSlider) {
      fontSlider.addEventListener('input', (e) => {
        updateFont(e.target.value);
      });
    }

    if (fontPrev) {
      fontPrev.addEventListener('click', () => {
        if (!fontSlider) {
          return;
        }

        const currentValue = parseInt(fontSlider.value);
        if (currentValue > 1) {
          updateFont(currentValue - 1);
        }
      });
    }

    if (fontNext) {
      fontNext.addEventListener('click', () => {
        if (!fontSlider) {
          return;
        }

        const currentValue = parseInt(fontSlider.value);
        if (currentValue < 100) {
          updateFont(currentValue + 1);
        }
      });
    }

    // Toggle font selector with 'f' key
    document.addEventListener('keydown', (e) => {
      if ((e.key === 'f' || e.key === 'F') && fontSelector) {
        fontSelector.classList.toggle('visible');
      }
    });

    // Color picker
    if (colorPicker) {
      colorPicker.addEventListener('input', (e) => {
        const selectedColor = e.target.value;
        if (colorValue) {
          colorValue.textContent = selectedColor;
        }
        if (liquidGlassText) {
          liquidGlassText.style.color = selectedColor;
        }
        
        // Update section title
        const sectionTitle = document.querySelector('.section-title');
        if (sectionTitle) {
          sectionTitle.style.color = selectedColor;
        }
        
        // Update all subtitles
        const subtitles = document.querySelectorAll('.info-card h3');
        subtitles.forEach(subtitle => {
          subtitle.style.color = selectedColor;
        });

        document.querySelectorAll('.timeline-date, .timeline-title').forEach(el => {
          el.style.color = selectedColor;
        });
      });
    }

    if (timeline && timelineOverlay) {
      document.addEventListener('mousemove', handleTimelinePointer);
      timeline.addEventListener('mouseleave', hideTimelineOverlay);
      window.addEventListener('resize', hideTimelineOverlay);
      window.addEventListener('scroll', hideTimelineOverlay, { passive: true });
      hideTimelineOverlay();
    }

    // Typing effect for Mission title
    const sectionTitle = document.querySelector('.section-title');
    const fullText = sectionTitle ? sectionTitle.textContent : '';
    let typingState = 'idle';
    let typingInterval = null;
    let backspaceInterval = null;

    if (sectionTitle) {
      sectionTitle.textContent = '';
      typingState = 'cleared';
    }

    function clearTypingTimers() {
      if (typingInterval) {
        clearInterval(typingInterval);
        typingInterval = null;
      }
      if (backspaceInterval) {
        clearInterval(backspaceInterval);
        backspaceInterval = null;
      }
    }

    function startTyping() {
      if (!sectionTitle || typingState === 'typing' || typingState === 'typed') {
        return;
      }

      clearTypingTimers();
      typingState = 'typing';
      sectionTitle.classList.add('typing');
      sectionTitle.textContent = '';
      let index = 0;

      typingInterval = setInterval(() => {
        if (index < fullText.length) {
          sectionTitle.textContent += fullText[index];
          index += 1;
        } else {
          clearTypingTimers();
          typingState = 'typed';
          setTimeout(() => {
            sectionTitle.classList.remove('typing');
          }, 120);
        }
      }, 100);
    }

    function startBackspace() {
      if (!sectionTitle || typingState === 'backspacing' || typingState === 'cleared') {
        return;
      }

      clearTypingTimers();
      typingState = 'backspacing';
      sectionTitle.classList.add('typing');

      backspaceInterval = setInterval(() => {
        const current = sectionTitle ? sectionTitle.textContent : '';
        if (current && current.length > 0) {
          sectionTitle.textContent = current.slice(0, -1);
        } else {
          clearTypingTimers();
          typingState = 'cleared';
          sectionTitle.classList.remove('typing');
        }
      }, 60);
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (!sectionTitle || entry.target !== sectionTitle) {
          return;
        }

        if (entry.isIntersecting) {
          startTyping();
        } else {
          startBackspace();
        }
      });
    }, { threshold: 0.5 });

    if (sectionTitle) {
      observer.observe(sectionTitle);
    }

    // Initialize with Permanent Marker font (number 68)
    updateFont(68);
  </script>
</body>
</html>
